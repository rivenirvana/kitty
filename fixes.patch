diff --git a/docs/color-stack.rst b/docs/color-stack.rst
index 465763571..6cf45e7f5 100644
--- a/docs/color-stack.rst
+++ b/docs/color-stack.rst
@@ -52,8 +52,8 @@ than numbers. The syntax of the escape code is::
     <OSC> 21 ; key=value ; key=value ; ... <ST>
 
 The spaces in the above definition are for reading clarity and should be ignored.
-Here, ``<OSC>`` is the two bytes ``0x1b (ESC)`` and ``0x5d (])``. ``ST`` is
-either ``0x7 (BEL)`` or the two bytes ``0x1b (ESC)`` and ``0x5c (\\)``.
+Here, ``<OSC>`` is the two bytes ``0x1b (ESC)`` and ``0x5d (])``. ``<ST>`` is
+either ``0x07 (BEL)`` or the two bytes ``0x1b (ESC)`` and ``0x5c (\\)``.
 
 ``key`` is a number from 0-255 to query or set the color values from the
 terminals ANSI color table, or one of the strings in the table below for
diff --git a/docs/mapping.rst b/docs/mapping.rst
index 098cdc96a..ce9a02ac1 100644
--- a/docs/mapping.rst
+++ b/docs/mapping.rst
@@ -201,7 +201,7 @@ In order to make this work, you need to configure your editor as show below:
    In :file:`~/.vimrc` add:
     .. code-block:: vim
 
-        let &t_ti = &t_ti . "\033]1337;SetUserVar=in_editor=MQo\007"
+        let &t_ti = &t_ti . "\033]1337;SetUserVar=in_editor=MQ==\007"
         let &t_te = &t_te . "\033]1337;SetUserVar=in_editor\007"
 
 .. tab:: neovim
@@ -214,9 +214,9 @@ In order to make this work, you need to configure your editor as show below:
             group = vim.api.nvim_create_augroup("KittySetVarVimEnter", { clear = true }),
             callback = function()
                 if vim.api.nvim_ui_send then
-                    vim.api.nvim_ui_send("\x1b]1337;SetUserVar=in_editor=MQo\007")
+                    vim.api.nvim_ui_send("\x1b]1337;SetUserVar=in_editor=MQ==\007")
                 else
-                    io.stdout:write("\x1b]1337;SetUserVar=in_editor=MQo\007")
+                    io.stdout:write("\x1b]1337;SetUserVar=in_editor=MQ==\007")
                 end
             end,
         })
@@ -225,7 +225,7 @@ In order to make this work, you need to configure your editor as show below:
             group = vim.api.nvim_create_augroup("KittyUnsetVarVimLeave", { clear = true }),
             callback = function()
                 if vim.api.nvim_ui_send then
-                    vim.api.nvim_ui_send("\x1b]1337;SetUserVar=in_editor=MQo\007")
+                    vim.api.nvim_ui_send("\x1b]1337;SetUserVar=in_editor\007")
                 else
                     io.stdout:write("\x1b]1337;SetUserVar=in_editor\007")
                 end
diff --git a/kitty/rc/scroll_window.py b/kitty/rc/scroll_window.py
index 51399d715..d33f475ca 100644
--- a/kitty/rc/scroll_window.py
+++ b/kitty/rc/scroll_window.py
@@ -29,7 +29,7 @@ class ScrollWindow(RemoteCommand):
         ' For example, :code:`30` will scroll down 30 lines, :code:`2p-`'
         ' will scroll up 2 pages and :code:`0.5p` will scroll down half page.'
         ' :code:`3u` will *unscroll* by 3 lines, which means that 3 lines will move from the'
-        ' scrollback buffer onto the top of the screen. :code:`1r-` will scroll to the previous prompt and 1r to the next prompt.'
+        ' scrollback buffer onto the top of the screen. :code:`1r-` will scroll to the previous prompt and :code:`1r` to the next prompt.'
         ' See :ac:`scroll_to_prompt` for details on how scrolling to prompt works.'
     )
     options_spec = MATCH_WINDOW_OPTION + '''\n
diff --git a/kitty/screen.c b/kitty/screen.c
index 7cbd16a0e..2e65172b4 100644
--- a/kitty/screen.c
+++ b/kitty/screen.c
@@ -4349,7 +4349,7 @@ find_cmd_output(Screen *self, OutputOffset *oo, index_type start_screen_y, unsig
             found_prompt = true;
             // change direction to downwards to find command output
             direction = 1;
-        } else if (line && line->attrs.prompt_kind == OUTPUT_START && !range_line_is_continued(self, y1)) {
+        } else if (line && line->attrs.prompt_kind == OUTPUT_START) {
             found_output = true; start = y1;
             found_prompt = true;
             direction = 1;
@@ -4363,13 +4363,13 @@ find_cmd_output(Screen *self, OutputOffset *oo, index_type start_screen_y, unsig
         // find upwards: find prompt after the output, and the first output
         while (y1 >= upward_limit) {
             line = checked_range_line(self, y1);
-            if (line && line->attrs.prompt_kind == PROMPT_START && !range_line_is_continued(self, y1)) {
+            if (line && line->attrs.prompt_kind == PROMPT_START) {
                 if (direction == 0) {
                     found_prompt = true;
                     break;
                 }
                 found_next_prompt = true; end = y1;
-            } else if (line && line->attrs.prompt_kind == OUTPUT_START && !range_line_is_continued(self, y1)) {
+            } else if (line && line->attrs.prompt_kind == OUTPUT_START) {
                 found_output = true; start = y1;
                 found_prompt = true;
                 break;
@@ -4395,12 +4395,12 @@ find_cmd_output(Screen *self, OutputOffset *oo, index_type start_screen_y, unsig
                         break;
                     }
                     found_prompt = true;
-                } else if (found_prompt && !found_output) {
+                } else if (!found_output) {
                     // skip fetching wrapped prompt lines
                     while (range_line_is_continued(self, y2)) {
                         y2++;
                     }
-                } else if (found_output && !found_next_prompt) {
+                } else if (!found_next_prompt) {
                     found_next_prompt = true; end = y2;
                     break;
                 }
@@ -4478,7 +4478,7 @@ cmd_output(Screen *self, PyObject *args) {
             bool reached_upper_limit = false;
             while (!found && !reached_upper_limit) {
                 line = checked_range_line(self, y);
-                if (!line || (line->attrs.prompt_kind == OUTPUT_START && !range_line_is_continued(self, y))) {
+                if (!line || (line->attrs.prompt_kind == OUTPUT_START)) {
                     int start = line ? y : y + 1; reached_upper_limit = !line;
                     int y2 = start; unsigned int num_lines = 0;
                     bool found_content = false;
diff --git a/kitty/window.py b/kitty/window.py
index f6d4243b8..9fcf982d7 100644
--- a/kitty/window.py
+++ b/kitty/window.py
@@ -2098,12 +2098,12 @@ def make_exe_absolute(cmd: list[str], pid: int) -> None:
 
     @ac('cp', 'Show scrollback in a pager like less')
     def show_scrollback(self) -> None:
-        text = self.as_text(as_ansi=True, add_history=True, add_wrap_markers=True)
+        text = self.as_text(as_ansi=True, add_history=True, add_wrap_markers=False)
         data = self.pipe_data(text, has_wrap_markers=True)
         cursor_on_screen = self.screen.scrolled_by < self.screen.lines - self.screen.cursor.y
         get_boss().display_scrollback(self, data['text'], data['input_line_number'], report_cursor=cursor_on_screen)
 
-    def show_cmd_output(self, which: CommandOutput, title: str = 'Command output', as_ansi: bool = True, add_wrap_markers: bool = True) -> None:
+    def show_cmd_output(self, which: CommandOutput, title: str = 'Command output', as_ansi: bool = True, add_wrap_markers: bool = False) -> None:
         text = self.cmd_output(which, as_ansi=as_ansi, add_wrap_markers=add_wrap_markers)
         text = text.replace('\r\n', '\n').replace('\r', '\n')
         get_boss().display_scrollback(self, text, title=title, report_cursor=False)
